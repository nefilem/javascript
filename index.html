<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <title>Adventure Game</title>
</head>
<body>    
    <canvas id="mainCanvas" width="600" height="400" tabindex="0"></canvas>
    <br>
    <canvas id="mapCanvas" width="200" height="200" tabindex="1" style="display:inline-block;"></canvas>
    <div id="mobilecontrols" style="display:inline-block;">
    <button type="button" onclick="moveViaButtons('q');">Turn Left</button>
    <button type="button" onclick="moveViaButtons('w');">Move Forward</button>
    <button type="button" onclick="moveViaButtons('e');">Turn Right</button>
    <br>
    <button type="button" onclick="moveViaButtons('a');">Move Left</button>
    <button type="button" onclick="moveViaButtons('s');">Move Backwards</button>
    <button type="button" onclick="moveViaButtons('d');">Move Right</button>    
    </div>

    <br>
    <p>Click the text to test</p>
    <br>
    <span onclick="clearCanvas(); drawWall(0);drawOpenDoor(200);drawWall(400);">Open door</span>
    <span onclick="clearCanvas(); drawDoor(125);">Close door</span>
    <span onclick="clearCanvas(); drawWall(125);">Draw Wall</span>
    <span onclick="drawMob();">Draw Mob</span>

    <script>
        let objcanvas = document.getElementById("mainCanvas");
        let context= objcanvas.getContext('2d');                

        let objmapcanvas = document.getElementById("mapCanvas");
        let mapcontext= objmapcanvas.getContext('2d');                

        let mazeDirection = 0; // 0 is north, 1 is east, 2 is south, 3 is west.
        let mazeArr = new Array();
        mazeArr[0]  = new Array(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1);
        mazeArr[1]  = new Array(1,0,0,0,0,1,0,0,0,0,2,0,0,0,0,0,0,0,0,1);
        mazeArr[2]  = new Array(1,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1);
        mazeArr[3]  = new Array(1,1,1,1,0,1,1,3,1,1,1,0,0,0,1,0,0,0,0,1);
        mazeArr[4]  = new Array(1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1);
        mazeArr[5]  = new Array(1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1);
        mazeArr[6]  = new Array(1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1);
        mazeArr[7]  = new Array(1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1);
        mazeArr[8]  = new Array(1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[9]  = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[10] = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[11] = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[12] = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[13] = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[14] = new Array(1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[15] = new Array(1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1);
        mazeArr[16] = new Array(1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1);
        mazeArr[17] = new Array(1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1);
        mazeArr[18] = new Array(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);
        mazeArr[19] = new Array(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1);

        let mazeRoomDescriptionsIDs = Array();
        mazeRoomDescriptionsIDs[0]  = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[1]  = Array(0,1,1,1,1,0,6,6,6,7,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[2]  = Array(0,1,1,1,1,0,6,8,6,6,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[3]  = Array(0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[4]  = Array(0,0,0,0,2,2,2,3,2,2,2,2,2,2,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[5]  = Array(0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[6]  = Array(0,0,0,4,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[7]  = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[8]  = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[9]  = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[10] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[11] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[12] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[13] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[14] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[15] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[16] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[17] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[18] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
        mazeRoomDescriptionsIDs[19] = Array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

        let mazeRoomDescriptions = Array();
        mazeRoomDescriptions[0]  = Array("");
        mazeRoomDescriptions[1]  = Array("Before you is a darkly lit entry hall, the floors are very dusty.");
        mazeRoomDescriptions[2]  = Array("You stand in the reception room, more lighting in this room reveals gold tabbards", "hanging from the walls.");
        mazeRoomDescriptions[3]  = Array("You stand in the reception room, nearby a large open door reveals a dimly lit room within.");
        mazeRoomDescriptions[4]  = Array("A small alcove within the reception room.");
        mazeRoomDescriptions[5]  = Array("You are in a corridor between rooms.");
        mazeRoomDescriptions[6]  = Array("");
        mazeRoomDescriptions[7]  = Array("");
        mazeRoomDescriptions[8]  = Array("");
        mazeRoomDescriptions[9]  = Array("");
        mazeRoomDescriptions[10] = Array("");
        mazeRoomDescriptions[11] = Array("");
        mazeRoomDescriptions[12] = Array("");
        mazeRoomDescriptions[13] = Array("");
        mazeRoomDescriptions[14] = Array("");
        mazeRoomDescriptions[15] = Array("");
        mazeRoomDescriptions[16] = Array("");
        mazeRoomDescriptions[17] = Array("");
        mazeRoomDescriptions[18] = Array("");
        mazeRoomDescriptions[19] = Array("");

        let mazePosX = 1;
        let mazePosY = 1;
        let mazePosZ = 1; // would be which floor effectively if there were stairs.

        clearCanvas();
        clearMapCanvas();
        drawScene();
        drawMap();

        $('#mainCanvas').on('keydown', function(event) {
            //console.log(event.keyCode);                      

            let mazeCoordsArr = [];

            switch(event.keyCode)
            {
                case 87:
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 0);
                    //alert("w pressed");                                
                    if ((mazeCoordsArr[1]) > 0) {                                                
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case 68:
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 1);
                    //alert("d pressed");
                    if ((mazeCoordsArr[0]) < 20) {                        
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case 65:
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 3);
                    //alert("a pressed");
                    if ((mazeCoordsArr[0]) > 0) {                        
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case 83:
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 2);
                    //alert("s pressed");
                    if ((mazeCoordsArr[1]) < 20) {
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case 69:
                    // q turn left
                    mazeDirection++;
                    if (mazeDirection > 3) { mazeDirection = 0;};
                    break;

                case 81:
                    // e turn right
                    --mazeDirection;
                    if (mazeDirection < 0) { mazeDirection = 3;};
                    break;
                
                default:
            }

            //$('#xpos').innerhtml = mazePosX;
            //$('#ypos').innerhtml = mazePosY;
            //console.log("X:" + mazePosX + ", Y:" + mazePosY + ", Direction:" + mazeDirection);

            clearCanvas();
            drawScene();
            clearMapCanvas();
            drawMap();
        });

        $(function() {
            $('#mainCanvas').focus();
        });

        function moveViaButtons(buttonID) {
            let mazeCoordsArr = [];

            switch(buttonID)
            {
                case "w":
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 0);
                    //alert("w pressed");                                
                    if ((mazeCoordsArr[1]) > 0) {                                                
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case "d":
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 1);
                    //alert("d pressed");
                    if ((mazeCoordsArr[0]) < 20) {                        
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case "a":
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 3);
                    //alert("a pressed");
                    if ((mazeCoordsArr[0]) > 0) {                        
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case "s":
                    mazeCoordsArr = returnNewCoords(mazePosX, mazePosY, mazeDirection, 2);
                    //alert("s pressed");
                    if ((mazeCoordsArr[1]) < 20) {
                        let tmpVar = mazeArr[mazeCoordsArr[1]][mazeCoordsArr[0]];
                        // 1 is wall, 2 is closed door
                        if (tmpVar != 1 && tmpVar != 2) {
                            mazePosX = mazeCoordsArr[0];
                            mazePosY = mazeCoordsArr[1];
                        } 
                    }
                    break;

                case "e":
                    // q turn left
                    mazeDirection++;
                    if (mazeDirection > 3) { mazeDirection = 0;};
                    break;

                case "q":
                    // e turn right
                    --mazeDirection;
                    if (mazeDirection < 0) { mazeDirection = 3;};
                    break;
                
                default:
            }
            
            clearCanvas();
            drawScene();
            clearMapCanvas();
            drawMap();
        }

        function drawScene() {
            let tmpVarLeft = -1;
            let tmpVar = 0;
            let tmpVarRight = -1;
            switch (mazeDirection) {
                case 0:                    
                    tmpVar = mazeArr[mazePosY-1][mazePosX];
                    if ((mazePosX-1)>-1) {tmpVarLeft = mazeArr[mazePosY-1][mazePosX-1];} else tmpVarLeft = -1;
                    if ((mazePosX+1)<21) {tmpVarRight = mazeArr[mazePosY-1][mazePosX+1];} else tmpVarRight = -1;
                    break;
                case 1:
                    tmpVar = mazeArr[mazePosY][mazePosX+1];
                    if ((mazePosY-1)>-1) {tmpVarLeft = mazeArr[mazePosY-1][mazePosX+1];} else tmpVarLeft = -1;
                    if ((mazePosY+1)<21) {tmpVarRight = mazeArr[mazePosY+1][mazePosX+1];} else tmpVarRight = -1;
                    break;
                case 2:
                    tmpVar = mazeArr[mazePosY+1][mazePosX];
                    if ((mazePosX+1)<21) {tmpVarLeft = mazeArr[mazePosY+1][mazePosX+1];} else tmpVarLeft = -1;
                    if ((mazePosX-1)>-1) {tmpVarRight = mazeArr[mazePosY+1][mazePosX-1];} else tmpVarRight = -1;
                    break;
                case 3:
                    tmpVar = mazeArr[mazePosY][mazePosX-1];
                    if ((mazePosY+1)<21) {tmpVarLeft = mazeArr[mazePosY+1][mazePosX-1];} else tmpVarLeft = -1;
                    if ((mazePosY-1)>-1) {tmpVarRight= mazeArr[mazePosY-1][mazePosX-1];} else tmpVarRight = -1;
                    break;
                default:
            }
            switch (tmpVar)
            {
                case 0:
                    // draw nothing, empty space
                    break;
                case 1:
                    drawWall(200);
                    break;
                case 2:
                    drawDoor(200);
                    break;
                case 3:
                    drawOpenDoor(200);
                    break;
                case 4:
                    break;
                default:
                    //again draw nothing                
            }
            switch (tmpVarLeft)
            {
                case 0:
                    // draw nothing, empty space
                    break;
                case 1:
                    drawWall(0);
                    break;
                case 2:
                    drawDoor(0);
                    break;
                case 3:
                    drawOpenDoor(0);
                    break;
                case 4:
                    break;
                default:
                    //again draw nothing                
            }

            switch (tmpVarRight)
            {
                case 0:
                    // draw nothing, empty space
                    break;
                case 1:
                    drawWall(400);
                    break;
                case 2:
                    drawDoor(400);
                    break;
                case 3:
                    drawOpenDoor(400);
                    break;
                case 4:
                    break;
                default:
                    //again draw nothing                
            }

            drawDescription(mazePosX, mazePosY);

        }

        function drawDescription(xPos, yPos)
        {
            // checks for description in mazeDescriptionIDs, if the value is 0 no description is available.
            let mazeID = 0;

            mazeID = mazeRoomDescriptionsIDs[yPos][xPos];

            context.font = "15px Arial";
            context.fillStyle = 'black';
            let textOffset = 0;

            if (mazeID != 0) {
                //context.fillText(mazeRoomDescriptions[mazeID], 5, 325+textOffset);                
                mazeRoomDescriptions[mazeID].forEach((item, index, array) => { 
                    /*array.forEach((item) => { 
                        context.fillText(item, 5, 325+textOffset);
                        textOffset+=20;
                    } */
                    context.fillText(item, 5, 325+textOffset);
                    textOffset+=20;
                });
            } else {
                context.fillText("No description", 5, 325);
            }
        }

        function returnNewCoords(mazePosXin, mazePosYin, mazeOrientationin, moveDirectionin) {

            let mazeCoordsArr = [];
            switch(mazeOrientationin)
            {
                case 0: // north
                    switch(moveDirectionin)
                    {
                        case 0: //forward
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin-1;
                            break;
                        case 1: //right                            
                            mazeCoordsArr[0] = mazePosXin+1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 2: //backwards
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin+1;
                            break;
                        case 3: //left                            
                            mazeCoordsArr[0] = mazePosXin-1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        default:
                    }
                    break;
                case 1: //east
                
                    switch(moveDirectionin)
                    {
                        case 0: //forward
                            mazeCoordsArr[0] = mazePosXin+1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 1: //right                            
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin+1;
                            break;
                        case 2: //backwards
                            mazeCoordsArr[0] = mazePosXin-1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 3: //left                            
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin-1;
                            break;
                        default:
                    }
                    break;
                case 2://south
                    switch(moveDirectionin)
                    {
                        case 0: //forward
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin+1;
                            break;
                        case 1: //right                            
                            mazeCoordsArr[0] = mazePosXin-1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 2: //backwards
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin-1;
                            break;
                        case 3: //left                            
                            mazeCoordsArr[0] = mazePosXin+1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        default:                        

                    }
                    break;
                case 3://west
                    switch(moveDirectionin)
                    {
                        case 0: //forward
                            mazeCoordsArr[0] = mazePosXin-1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 1: //right                            
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin-1;
                            break;
                        case 2: //backwards
                            mazeCoordsArr[0] = mazePosXin+1;
                            mazeCoordsArr[1] = mazePosYin;
                            break;
                        case 3: //left                            
                            mazeCoordsArr[0] = mazePosXin;
                            mazeCoordsArr[1] = mazePosYin+1;
                            break;
                        default:
                    }
                    break;
                default:
                    
            }

            return mazeCoordsArr;
        }

        function clearCanvas() {

            // clear the canvas using clearRect()

            context.beginPath();
            context.clearRect(0, 0, 600, 600);
            context.stroke();

        };
        
        function clearMapCanvas() {

            // clear the canvas using clearRect()

            mapcontext.beginPath();
            mapcontext.clearRect(0, 0, 200, 200);
            mapcontext.stroke();

        };

        function drawMap()
        {
            mazeArr.forEach((itemY, indexY, arrayY) => itemY.forEach((itemX, indexX, arrayX) => drawMapBlock(indexX, indexY)));
        }

        function drawMapBlock(posX, posY)
        {
            mapcontext.beginPath();
            switch (mazeArr[posY][posX])
            {
                case 0:
                    //nothing to draw
                    break;
                case 1:
                    //wall
                    mapcontext.rect(posX*10, posY*10, 10, 10);                    
                    mapcontext.lineWidth = 1;
                    mapcontext.fillStyle = 'black';
                    mapcontext.fill();
                    mapcontext.strokeStyle = 'black';
                    mapcontext.stroke();
                    break;
            }
            // draw your position on map plus direction
            mapcontext.beginPath();
            mapcontext.rect(mazePosX*10, mazePosY*10, 10, 10);
            mapcontext.fillStyle = 'yellow';
            mapcontext.fill();
            mapcontext.strokeStyle='yellow';
            mapcontext.stroke();

            mapcontext.beginPath();
            switch (mazeDirection)
            {
                case 0:
                    mapcontext.rect(mazePosX*10, mazePosY*10, 10, 2);
                    break;
                case 1:
                    mapcontext.rect((mazePosX*10)+8, mazePosY*10, 2, 10);
                    break;
                case 2:
                    mapcontext.rect(mazePosX*10, (mazePosY*10)+8, 10, 2);
                    break;
                case 3:
                    mapcontext.rect(mazePosX*10, mazePosY*10, 2, 10);
                    break;
                default:
            }
            mapcontext.fillStyle = 'red';
            mapcontext.fill();
            mapcontext.strokeStyle='red';
            mapcontext.stroke();

        }

        function drawOpenDoor(offset) {
            
            context.beginPath();
            context.rect(0+offset,100,200,200);
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.rect(50+offset,150,100,150);                    
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.rect(50+offset,150,10,150);        
            context.fillStyle = "blue";
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.arc(offset+45,225,5,2 * Math.PI, false);        
            context.fillStyle = "white";
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

        }

        function drawDoor(offset) {

            context.beginPath();
            context.rect(0+offset,100,200,200);
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.rect(50+offset,150,100,150);        
            context.fillStyle = "blue";
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.arc(140+offset,225,5,2 * Math.PI, false);        
            context.fillStyle = "white";
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();
        }

        function drawWall(offset) {

            context.beginPath();
            context.rect(0+offset,100,200,200);
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

        }

        function drawMob() {

            context.beginPath();
            context.arc(150, 200, 50, 0, 360);
            context.fillStyle = 'yellow';
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

            context.beginPath();
            context.arc(150, 150, 25, 0, 360);
            context.fillStyle = 'red';
            context.fill();
            context.lineWidth=2;
            context.strokeStyle = 'black';
            context.stroke();

        }


    </script>
</body>
</html>